<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title> The Hatch </title>
		<link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
		<style>
			body {
				margin: 0;
				overflow: hidden;
				display: flex;
				flex-direction: column;
				justify-content: center;
				background: black;
				color: white;
				font-size: 2cm;
				font-family: 'Anton', sans-serif;
			}
			.horizcontainer {
				display: flex;
				flex-direction: row;
				justify-content: center;
			}
			#c {
				width:100vh;
				height:100vh;
			}
			.overlay {
				position: absolute;
				width:100%;
				height:100%;
				color: white;
				display: flex;
				flex-direction: column;
				justify-content: center;
			}
			.overlay-bottom {
				position: absolute;
				width: 100%;
				height: 100%;
				color: white;
				display: flex;
				flex-direction: column;
				justify-content: flex-end;
			}
			.overlay-top {
				position: absolute;
				width: 100%;
				height: 100%;
				color: white;
				display: flex;
				flex-direction: column;
				justify-content: flex-start;
			}
			.buffer {
				height: 50px;
			}
			#footer {
				text-align: center;;
			}
			#title {
				
			}
		</style>
		<script src="https://threejs.org/build/three.js"> </script>
	</head>
	<body>
		<div class="horizcontainer">
			<canvas id="c">
			</canvas>
			<div class="overlay-top">
				<div class="buffer">

				</div>
				<div class="horizcontainer" id='header'>
					<iframe id="player" width="50%" height="50" src="https://s1.citrus3.com:2000/AudioPlayer/TheHatch?mount=/stream&" border="0" style="border: 0;"></iframe>
					
				</div>
			</div>
			<div class="overlay">
				<div class="horizcontainer" id="title">
					THE HATCH
				</div>
			</div>
			<div class="overlay-bottom">
				<div class="horizcontainer" id='footer'>
					Next Live Session:  Martin @ 8:00pm 3rd May 
				</div>
				<div class="buffer">
					
				</div>
			</div>
			
		</div>
	</body>
	<script>
	
	
		class Section {
			constructor(zpos, sectionlist){
				let hatchsize = sectionlist.hatchsize
				let wallthickness = sectionlist.wallthickness
				let sectionsize = sectionlist.sectionsize
				let ladderoffsetfromwall = sectionlist.ladderoffsetfromwall
				let ladderwidth = sectionlist.ladderwidth
				let ladderheight = sectionlist.ladderheight
				let material = sectionlist.material
				let ladderhorizwidth = hatchsize - (2 * (ladderoffsetfromwall + wallthickness))
				this.allobjects = []

				this.right = new THREE.BoxGeometry(wallthickness, hatchsize, sectionsize);
				this.rightwall = new THREE.Mesh(this.right, material);
				scene.add(this.rightwall)
				this.rightwall.position.x = hatchsize /2

				this.left = new THREE.BoxGeometry(wallthickness, hatchsize, sectionsize);
				this.leftwall = new THREE.Mesh(this.left, material);
				scene.add(this.leftwall);
				this.leftwall.position.x = (hatchsize / 2) * -1

				this.ttop = new THREE.BoxGeometry(hatchsize, wallthickness, sectionsize);
				this.ttopwall = new THREE.Mesh(this.ttop, material);
				scene.add(this.ttopwall);
				this.ttopwall.position.y = hatchsize / 2

				this.bottom = new THREE.BoxGeometry(hatchsize, wallthickness, sectionsize);
				this.bottomwall = new THREE.Mesh(this.bottom, material);
				scene.add(this.bottomwall);
				this.bottomwall.position.y = (hatchsize / 2) * -1

				this.leftladdergeom = new THREE.BoxGeometry(ladderwidth, ladderheight, sectionsize);
				this.leftladder = new THREE.Mesh(this.leftladdergeom, material);
				scene.add(this.leftladder);
				this.leftladder.position.y = ((hatchsize / 2) * -1) + wallthickness
				this.leftladder.position.x = ((hatchsize / 2) * -1) + wallthickness + ladderoffsetfromwall

				this.rightladdergeom = new THREE.BoxGeometry(ladderwidth, ladderheight, sectionsize);
				this.rightladder = new THREE.Mesh(this.rightladdergeom, material);
				scene.add(this.rightladder);
				this.rightladder.position.y = ((hatchsize / 2) * -1) + wallthickness
				this.rightladder.position.x = ((hatchsize / 2)) - wallthickness - ladderoffsetfromwall

				this.horizladdergeom = new THREE.BoxGeometry(ladderhorizwidth, ladderheight, ladderwidth);
				this.horizladder = new THREE.Mesh(this.horizladdergeom, material);
				scene.add(this.horizladder);
				this.horizladder.position.y = ((hatchsize / 2) * -1) + wallthickness
				
				var hue = Math.floor(Math.random() * 360).toString()
				var color = new THREE.Color("hsl(" + hue + ", 100%, 50%)");
				this.light = new THREE.PointLight(color, 0.078, 0, 1000)
				let innergap = (hatchsize - (1 * wallthickness))
				let lightposx = (Math.random() * innergap) - (innergap / 2)
				let lightposy = (Math.random() * innergap) - (innergap / 2)
				this.light.position.set(lightposx, lightposy, 0)
				scene.add(this.light);
				
				this.allobjects.push(this.rightwall)
				this.allobjects.push(this.leftwall)
				this.allobjects.push(this.ttopwall)
				this.allobjects.push(this.bottomwall)
				this.allobjects.push(this.leftladder)
				this.allobjects.push(this.rightladder)
				this.allobjects.push(this.horizladder)
				this.allobjects.push(this.light)
				this.translatez(zpos)
				this.randomise()
			}
			
			translatez(zamount){
				this.allobjects.map((anobject) => {
					anobject.position.z += zamount
				})
			}
			
			randomise(){
				this.allobjects.map((anobject) => {
					if(anobject.type == "Mesh"){
						let xscale = (Math.random() / 10) - 0.05 + 1
						let yscale = (Math.random() / 10) - 0.05 + 1
						anobject.scale.set(xscale, yscale, 1)
						let rotate = (Math.random() /10) - 0.05
						anobject.rotation.z = rotate
					} else
					{
						var hue = Math.floor(Math.random() * 360).toString()
						var color = new THREE.Color("hsl(" + hue + ", 100%, 50%)");
						anobject.color = color
					}
				})
			}
		}
		
		class Hatch {
			constructor(numsections){
				this.hatchsize = 1; // xy size of hatch
				this.wallthickness = 0.1
				this.sectionsize = 0.37; // depth of each section
				this.ladderoffsetfromwall = 0.178
				this.ladderwidth = 0.078
				this.ladderheight = 0.078
				this.material = new THREE.MeshPhongMaterial({color: 0x696969});
				this.sections = []
				this.numsections = numsections
				this.firstsectionindex = 0
				this.overlap = 0.1
				this.generatesections()
			}
			
			addsection(){
				let zpositionofnew = (this.sections.length * (this.sectionsize - this.overlap ) * -1) + this.overlap 
				this.sections.push(new Section(zpositionofnew, this))
			}
			
			generatesections(){
				for (var i = 0; i < this.numsections; i++) {
					this.addsection()
				}
			}
			
			translatez(zamount){
				this.sections.map((asection => {asection.translatez(zamount)}))
			}
			
			rotate(){
				let firstsection = this.sections[this.firstsectionindex]
				if (firstsection.bottomwall.position.z + (this.sectionsize / 2) > camera.position.z + 0.2){
					this.firstsectionindex += 1
					if (this.firstsectionindex == this.sections.length) {
						this.firstsectionindex = 0
					}
					firstsection.translatez(this.sections.length * (this.sectionsize - this.overlap ) * -1) + this.overlap 			
					firstsection.randomise()
				}
			}
		}	
		
		class Cyclic {
			constructor(period, range) {
				this.period = period
				this.range = range
			}
			
			getval(numiterations) {
				// numiterations will be big Int16Array
				let yposition = numiterations % BigInt(this.period)
				let yangle = Math.sin((Number(yposition) / this.period) * Math.PI * 2)
				return  yangle * this.range
			}
		}
		
		function resizeRendererToDisplaySize(renderer)
		{
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
				renderer.setSize(width, height, false);
			}
			return needResize;
		}
		
		
		
		const canvas = document.querySelector('#c');
		const renderer = new THREE.WebGLRenderer({canvas});
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.antialias = true
	
		// change fontsize
		let reldist = 0
		if (canvas.clientHeight > canvas.clientWidth) {
			reldist = canvas.clientWidth
		}
		else {
			reldist = canvas.clientHeight
		}
		
		let fontsize = Math.floor(reldist / 20).toString() + 'px'
		let titlefontsize = Math.floor(reldist / 17.8).toString() + 'px'
		
		document.getElementById("header").style.fontSize = fontsize;
		document.getElementById("title").style.fontSize = titlefontsize;
		document.getElementById("footer").style.fontSize = fontsize;

		let playerwidth = Math.floor(reldist * 0.75).toString() + 'px'
		let playerheight = Math.floor(reldist * 0.12).toString() + 'px'
		document.getElementById("player").style.width = playerwidth;
		document.getElementById("player").style.height = playerheight;
		
		let bufferheight = Math.floor(canvas.clientHeight * 0.25).toString() + 'px'
		document.querySelectorAll('.buffer').forEach(function(abuffer) {
			abuffer.style.height = bufferheight
		});
		
		
		const fov = 75;
		const aspect = 1;  // the canvas default
		const near = 0.1;
		const far = 100;
		const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		
		camera.aspect = canvas.clientWidth / canvas.clientHeight;
		camera.updateProjectionMatrix()
		camera.position.z = 1;
		
		const scene = new THREE.Scene();
		
		myhatch = new Hatch(35)
		
		renderer.render(scene, camera);
		
		var footer = document.getElementById('footer')
		let numiterations = BigInt(0)
		ycyclic = new Cyclic(10, 0.045)
		xcyclic = new Cyclic(31, 0.02)
		angcyclic = new Cyclic(27, 0.03)
		advancecamera = function() {
			numiterations += BigInt(1)
			camera.position.y = ycyclic.getval(numiterations)
			camera.position.x = xcyclic.getval(numiterations)
			camera.rotation.z = angcyclic.getval(numiterations)
			camera.aspect = canvas.clientWidth / canvas.clientHeight;
			camera.updateProjectionMatrix()
			myhatch.translatez(0.044)
			myhatch.rotate()
			renderer.render(scene, camera);
		};
			
		setInterval(advancecamera, 200)
		
	</script>
</html>
